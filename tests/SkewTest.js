(function() {
  var __imul = Math.imul ? Math.imul : function(a, b) {
    return (a * (b >>> 16) << 16) + a * (b & 65535) | 0;
  };

  function assert(truth) {
    if (!truth) {
      throw Error('Assertion failed');
    }
  }

  function main() {
    // First, let's test reading a FlatBuffer generated by C++ code:
    // This file was generated from monsterdata_test.json
    var data = new Uint8Array(fs.readFileSync('monsterdata_test.mon'));
    var bb = new FlatBuffers.ByteBuffer(data);
    testBuffer(bb);

    // Second, let's create a FlatBuffer from scratch in JavaScript, and test it also.
    // We use an initial size of 1 to exercise the reallocation algorithm,
    // normally a size larger than the typical FlatBuffer you generate would be
    // better for performance.
    var fbb = new FlatBuffers.Builder(1);
    var str = fbb.createString('MyMonster');
    var inv = MyGame.Example.Monster.createInventoryVector(fbb, [0, 1, 2, 3, 4]);
    var fred = fbb.createString('Fred');
    MyGame.Example.Monster.startMonster(fbb);
    MyGame.Example.Monster.addName(fbb, fred);
    var mon2 = MyGame.Example.Monster.endMonster(fbb);
    MyGame.Example.Monster.startTest4Vector(fbb, 2);
    MyGame.Example.Test.createTest(fbb, 10, 20);
    MyGame.Example.Test.createTest(fbb, 30, 40);
    var test4 = MyGame.Example.Monster.endTest4Vector(fbb);
    var testArrayOfString = MyGame.Example.Monster.createTestarrayofstringVector(fbb, [fbb.createString('test1'), fbb.createString('test2')]);
    MyGame.Example.Monster.startMonster(fbb);
    MyGame.Example.Monster.addPos(fbb, MyGame.Example.Vec3.createVec3(fbb, 1, 2, 3, 3, MyGame.Example.Color.Green, 5, 6));
    MyGame.Example.Monster.addHp(fbb, 80);
    MyGame.Example.Monster.addName(fbb, str);
    MyGame.Example.Monster.addInventory(fbb, inv);
    MyGame.Example.Monster.addTestType(fbb, MyGame.Example.Any.Monster);
    MyGame.Example.Monster.addTest(fbb, mon2);
    MyGame.Example.Monster.addTest4(fbb, test4);
    MyGame.Example.Monster.addTestarrayofstring(fbb, testArrayOfString);
    MyGame.Example.Monster.addTestbool(fbb, false);
    var mon = MyGame.Example.Monster.endMonster(fbb);
    MyGame.Example.Monster.finishMonsterBuffer(fbb, mon);
    fs.writeFileSync('monsterdata_skew_wire.mon', new Buffer(fbb.asUint8Array()));

    // Test it:
    testBuffer(fbb.dataBuffer());
    test64bit();
    testUnicode();
    fuzzTest1();
    console.log('FlatBuffers test: completed successfully');
  }

  function testBuffer(bb) {
    assert(MyGame.Example.Monster.bufferHasIdentifier(bb));
    var monster = MyGame.Example.Monster.getRootAsMonster(bb);
    assert(MyGame.Example.Monster.hp(monster, bb) == 80);

    // default
    assert(MyGame.Example.Monster.mana(monster, bb) == 150);
    assert(MyGame.Example.Monster.name(monster, bb) == 'MyMonster');
    var pos = MyGame.Example.Monster.pos(monster, bb);
    assert(MyGame.Example.Vec3.x(pos, bb) == 1);
    assert(MyGame.Example.Vec3.y(pos, bb) == 2);
    assert(MyGame.Example.Vec3.z(pos, bb) == 3);
    assert(MyGame.Example.Vec3.test1(pos, bb) == 3);
    assert(MyGame.Example.Vec3.test2(pos, bb) == MyGame.Example.Color.Green);
    var t = MyGame.Example.Vec3.test3(pos, bb);
    assert(MyGame.Example.Test.a(t, bb) == 5);
    assert(MyGame.Example.Test.b(t, bb) == 6);
    assert(MyGame.Example.Monster.testType(monster, bb) == MyGame.Example.Any.Monster);
    var monster2 = MyGame.Example.Monster.test(monster, bb);
    assert(monster2 != MyGame.Example.Monster.NULL);
    assert(MyGame.Example.Monster.name(monster2, bb) == 'Fred');
    assert(MyGame.Example.Monster.inventoryLength(monster, bb) == 5);
    var invsum = 0;

    for (var i = 0, count = MyGame.Example.Monster.inventoryLength(monster, bb); i < count; i = i + 1 | 0) {
      invsum = invsum + MyGame.Example.Monster.inventory(monster, bb, i) | 0;
    }

    assert(invsum == 10);
    assert(MyGame.Example.Monster.test4Length(monster, bb) == 2);
    var test_0 = MyGame.Example.Monster.test4(monster, bb, 0);
    var test_1 = MyGame.Example.Monster.test4(monster, bb, 1);
    assert((((MyGame.Example.Test.a(test_0, bb) + MyGame.Example.Test.b(test_0, bb) | 0) + MyGame.Example.Test.a(test_1, bb) | 0) + MyGame.Example.Test.b(test_1, bb) | 0) == 100);
    assert(MyGame.Example.Monster.testarrayofstringLength(monster, bb) == 2);
    assert(MyGame.Example.Monster.testarrayofstring(monster, bb, 0) == 'test1');
    assert(MyGame.Example.Monster.testarrayofstring(monster, bb, 1) == 'test2');
    assert(MyGame.Example.Monster.testbool(monster, bb) == false);
  }

  function test64bit() {
    var fbb = FlatBuffers.Builder.new1();
    var required = fbb.createString('required');
    MyGame.Example.Stat.startStat(fbb);
    var stat2 = MyGame.Example.Stat.endStat(fbb);
    MyGame.Example.Monster.startMonster(fbb);
    MyGame.Example.Monster.addName(fbb, required);
    MyGame.Example.Monster.addTestempty(fbb, stat2);
    var mon2 = MyGame.Example.Monster.endMonster(fbb);
    MyGame.Example.Stat.startStat(fbb);
    MyGame.Example.Stat.addVal(fbb, new FlatBuffers.Long(305419896, 591751049));
    var stat = MyGame.Example.Stat.endStat(fbb);
    MyGame.Example.Monster.startMonster(fbb);
    MyGame.Example.Monster.addName(fbb, required);
    MyGame.Example.Monster.addEnemy(fbb, mon2);
    MyGame.Example.Monster.addTestempty(fbb, stat);
    var mon3 = MyGame.Example.Monster.endMonster(fbb);
    MyGame.Example.Monster.finishMonsterBuffer(fbb, mon3);
    var bytes = fbb.asUint8Array();
    var bb = new FlatBuffers.ByteBuffer(bytes);
    assert(MyGame.Example.Monster.bufferHasIdentifier(bb));
    var mon4 = MyGame.Example.Monster.getRootAsMonster(bb);
    var stat3 = MyGame.Example.Monster.testempty(mon4, bb);
    assert(stat3 != MyGame.Example.Stat.NULL);
    assert(MyGame.Example.Stat.val(stat3, bb) != null);
    assert(MyGame.Example.Stat.val(stat3, bb).low == 305419896);
    assert(MyGame.Example.Stat.val(stat3, bb).high == 591751049);
    var mon5 = MyGame.Example.Monster.enemy(mon4, bb);
    assert(mon5 != MyGame.Example.Monster.NULL);
    stat3 = MyGame.Example.Monster.testempty(mon5, bb);
    assert(stat3 != MyGame.Example.Stat.NULL);
    assert(MyGame.Example.Stat.val(stat3, bb) != null);

    // default value
    assert(MyGame.Example.Stat.val(stat3, bb).low == 0);
    assert(MyGame.Example.Stat.val(stat3, bb).high == 0);
  }

  function testUnicode() {
    var correct = fs.readFileSync('unicode_test.mon');
    var json = JSON.parse(fs.readFileSync('unicode_test.json', 'utf8'));

    // Test reading
    var testReadingUnicode = function(bb) {
      var monster = MyGame.Example.Monster.getRootAsMonster(bb);
      assert(MyGame.Example.Monster.name(monster, bb) === json.name);
      assert(MyGame.Example.Monster.testarrayoftablesLength(monster, bb) === json.testarrayoftables.length);
      json.testarrayoftables.forEach(function(table, i) {
        var value = MyGame.Example.Monster.testarrayoftables(monster, bb, i);
        assert(MyGame.Example.Monster.name(value, bb) === table.name);
      });
      assert(MyGame.Example.Monster.testarrayofstringLength(monster, bb) === json.testarrayofstring.length);
      json.testarrayofstring.forEach(function(value, i) {
        assert(MyGame.Example.Monster.testarrayofstring(monster, bb, i) == value);
      });
    };
    testReadingUnicode(new FlatBuffers.ByteBuffer(new Uint8Array(correct)));

    // Test writing
    var fbb = FlatBuffers.Builder.new1();
    var name = fbb.createString(json.name);
    var testarrayoftablesOffsets = json.testarrayoftables.map(function(table) {
      var name = fbb.createString(table.name);
      MyGame.Example.Monster.startMonster(fbb);
      MyGame.Example.Monster.addName(fbb, name);
      return MyGame.Example.Monster.endMonster(fbb);
    });
    var testarrayoftablesOffset = MyGame.Example.Monster.createTestarrayoftablesVector(fbb, testarrayoftablesOffsets);
    var testarrayofstringOffset = MyGame.Example.Monster.createTestarrayofstringVector(fbb, json.testarrayofstring.map(function(s) {
      return fbb.createString(s);
    }));
    MyGame.Example.Monster.startMonster(fbb);
    MyGame.Example.Monster.addTestarrayofstring(fbb, testarrayofstringOffset);
    MyGame.Example.Monster.addTestarrayoftables(fbb, testarrayoftablesOffset);
    MyGame.Example.Monster.addName(fbb, name);
    MyGame.Example.Monster.finishMonsterBuffer(fbb, MyGame.Example.Monster.endMonster(fbb));
    testReadingUnicode(new FlatBuffers.ByteBuffer(fbb.asUint8Array()));
  }

  function rand() {
    return rand_seed = __imul(rand_seed, 1103515245) + 12345 & 2147483647;
  }

  function rand_reset() {
    rand_seed = 1;
  }

  // Converts a Field ID to a virtual table offset.
  function fieldIndexToOffset(field_id) {
    // Should correspond to what EndTable() below builds up.
    // Vtable size and Object Size.
    var fixed_fields = 2;
    return __imul(field_id + fixed_fields | 0, 2);
  }

  // Low level stress/fuzz test: serialize/deserialize a variety of
  // different kinds of data in different combinations
  function fuzzTest1() {
    // Values we're testing against: chosen to ensure no bits get chopped
    // off anywhere, and also be different from eachother.
    var bool_val = true;

    // 0x81
    var char_val = -127;
    var uchar_val = 255;

    // 0x8222;
    var short_val = -32222;
    var ushort_val = 65262;
    var int_val = -2093796557 | 0;
    var uint_val = -35791395;
    var long_val = new FlatBuffers.Long(1145324612, -2075900860);
    var ulong_val = new FlatBuffers.Long(-858993460, -53687092);
    var float_val = new Float32Array([3.14159])[0];
    var double_val = 3.14159265359;
    var test_values_max = 11;
    var fields_per_object = 4;

    // The higher, the more thorough :)
    var num_fuzz_objects = 10000;
    var builder = FlatBuffers.Builder.new1();

    // Keep it deterministic.
    rand_reset();
    var objects = [];

    // Generate num_fuzz_objects random objects each consisting of
    // fields_per_object fields, each of a random type.
    for (var i = 0, count1 = num_fuzz_objects; i < count1; i = i + 1 | 0) {
      builder.startObject(fields_per_object);

      for (var f = 0, count = fields_per_object; f < count; f = f + 1 | 0) {
        var choice = rand() % test_values_max | 0;

        switch (choice) {
          case 0: {
            builder.addFieldInt8(f, bool_val | 0, 0);
            break;
          }

          case 1: {
            builder.addFieldInt8(f, char_val, 0);
            break;
          }

          case 2: {
            builder.addFieldInt8(f, uchar_val, 0);
            break;
          }

          case 3: {
            builder.addFieldInt16(f, short_val, 0);
            break;
          }

          case 4: {
            builder.addFieldInt16(f, ushort_val, 0);
            break;
          }

          case 5: {
            builder.addFieldInt32(f, int_val, 0);
            break;
          }

          case 6: {
            builder.addFieldInt32(f, uint_val, 0);
            break;
          }

          case 7: {
            builder.addFieldInt64(f, long_val, FlatBuffers.Long.ZERO);
            break;
          }

          case 8: {
            builder.addFieldInt64(f, ulong_val, FlatBuffers.Long.ZERO);
            break;
          }

          case 9: {
            builder.addFieldFloat32(f, float_val, 0);
            break;
          }

          case 10: {
            builder.addFieldFloat64(f, double_val, 0);
            break;
          }
        }
      }

      objects.push(builder.endObject());
    }

    // Align whole buffer.
    builder.prep(8, 0);

    // Reset.
    rand_reset();
    builder.finish(in_List.get(objects, in_List.count(objects) - 1 | 0), null);
    var bytes = new Uint8Array(builder.asUint8Array());
    var view = new DataView(bytes.buffer);

    // Test that all objects we generated are readable and return the
    // expected values. We generate random objects in the same order
    // so this is deterministic.
    for (var i1 = 0, count3 = num_fuzz_objects; i1 < count3; i1 = i1 + 1 | 0) {
      var offset = bytes.length - in_List.get(objects, i1) | 0;

      for (var f1 = 0, count2 = fields_per_object; f1 < count2; f1 = f1 + 1 | 0) {
        var choice1 = rand() % test_values_max | 0;
        var vtable_offset = fieldIndexToOffset(f1);
        var vtable = offset - view.getInt32(offset, true) | 0;
        assert(vtable_offset < view.getInt16(vtable, true));
        var field_offset = offset + view.getInt16(vtable + vtable_offset | 0, true) | 0;

        switch (choice1) {
          case 0: {
            assert(!!view.getInt8(field_offset) == bool_val);
            break;
          }

          case 1: {
            assert(view.getInt8(field_offset) == char_val);
            break;
          }

          case 2: {
            assert(view.getUint8(field_offset) == uchar_val);
            break;
          }

          case 3: {
            assert(view.getInt16(field_offset, true) == short_val);
            break;
          }

          case 4: {
            assert(view.getUint16(field_offset, true) == ushort_val);
            break;
          }

          case 5: {
            assert(view.getInt32(field_offset, true) == int_val);
            break;
          }

          case 6: {
            assert((view.getUint32(field_offset, true) | 0) == uint_val);
            break;
          }

          case 7: {
            assert(view.getInt32(field_offset, true) == long_val.low);
            assert(view.getInt32(field_offset + 4 | 0, true) == long_val.high);
            break;
          }

          case 8: {
            assert(view.getInt32(field_offset, true) == ulong_val.low);
            assert(view.getInt32(field_offset + 4 | 0, true) == ulong_val.high);
            break;
          }

          case 9: {
            assert(view.getFloat32(field_offset, true) == float_val);
            break;
          }

          case 10: {
            assert(view.getFloat64(field_offset, true) == double_val);
            break;
          }
        }
      }
    }
  }

  function StringBuilder() {
    this.buffer = '';
  }

  StringBuilder.prototype.append = function(x) {
    this.buffer += x;
  };

  StringBuilder.prototype.toString = function() {
    return this.buffer;
  };

  var Unicode = {};

  Unicode.StringIterator = function() {
    this.value = '';
    this.index = 0;
    this.stop = 0;
  };

  Unicode.StringIterator.prototype.reset = function(text, start) {
    this.value = text;
    this.index = start;
    this.stop = in_string.count(text);
    return this;
  };

  Unicode.StringIterator.prototype.nextCodePoint = function() {
    if (this.index >= this.stop) {
      return -1;
    }

    var a = in_string.get1(this.value, (this.index = this.index + 1 | 0) + -1 | 0);

    if (a < 55296 || a >= 56320) {
      return a;
    }

    if (this.index >= this.stop) {
      return -1;
    }

    var b = in_string.get1(this.value, (this.index = this.index + 1 | 0) + -1 | 0);
    return ((a << 10) + b | 0) + ((65536 - (55296 << 10) | 0) - 56320 | 0) | 0;
  };

  var FlatBuffers = {};

  FlatBuffers.Long = function(low, high) {
    this.low = low;
    this.high = high;
  };

  FlatBuffers.Long.prototype.isEqualTo = function(other) {
    return this.low == other.low && this.high == other.high;
  };

  FlatBuffers.Builder = function(space) {
    this._bb = null;
    this._space = 0;
    this._minAlign = 1;
    this._vtableInUse = 0;
    this._vtable = [];
    this._isNested = false;
    this._objectStart = 0;
    this._vtables = [];
    this._vectorCount = 0;
    this._forceDefaults = false;
    this._bb = new FlatBuffers.ByteBuffer.new2(space);
    this._space = space;
  };

  // Get the ByteBuffer representing the FlatBuffer. Only call this after
  // you've called "finish". The actual data starts at the ByteBuffer's
  // current position, not necessarily at 0.
  FlatBuffers.Builder.prototype.dataBuffer = function() {
    return this._bb;
  };

  // Get the ByteBuffer representing the FlatBuffer. Only call this after
  // you've called "finish". The actual data starts at the ByteBuffer's
  // current position, not necessarily at 0.
  FlatBuffers.Builder.prototype.asUint8Array = function() {
    return this._bb.bytes().subarray(this._bb.position(), this._bb.position() + this.offset() | 0);
  };

  // Set the current vtable at "voffset" to the current location in the buffer.
  FlatBuffers.Builder.prototype.slot = function(voffset) {
    in_List.set(this._vtable, voffset, this.offset());
  };

  FlatBuffers.Builder.prototype.offset = function() {
    return this._bb.capacity() - this._space | 0;
  };

  FlatBuffers.Builder.prototype.writeInt8 = function(value) {
    this._space = this._space - 1 | 0;
    this._bb.writeInt8(this._space, value);
  };

  FlatBuffers.Builder.prototype.writeInt16 = function(value) {
    this._space = this._space - 2 | 0;
    this._bb.writeInt16(this._space, value);
  };

  FlatBuffers.Builder.prototype.writeInt32 = function(value) {
    this._space = this._space - 4 | 0;
    this._bb.writeInt32(this._space, value);
  };

  FlatBuffers.Builder.prototype.writeInt64 = function(value) {
    this._space = this._space - 8 | 0;
    this._bb.writeInt64(this._space, value);
  };

  FlatBuffers.Builder.prototype.writeFloat32 = function(value) {
    this._space = this._space - 4 | 0;
    this._bb.writeFloat32(this._space, value);
  };

  FlatBuffers.Builder.prototype.writeFloat64 = function(value) {
    this._space = this._space - 8 | 0;
    this._bb.writeFloat64(this._space, value);
  };

  FlatBuffers.Builder.prototype.addInt8 = function(value) {
    this.prep(1, 0);
    this.writeInt8(value);
  };

  FlatBuffers.Builder.prototype.addInt16 = function(value) {
    this.prep(2, 0);
    this.writeInt16(value);
  };

  FlatBuffers.Builder.prototype.addInt32 = function(value) {
    this.prep(4, 0);
    this.writeInt32(value);
  };

  FlatBuffers.Builder.prototype.addInt64 = function(value) {
    this.prep(8, 0);
    this.writeInt64(value);
  };

  FlatBuffers.Builder.prototype.addFloat32 = function(value) {
    this.prep(4, 0);
    this.writeFloat32(value);
  };

  FlatBuffers.Builder.prototype.addFloat64 = function(value) {
    this.prep(8, 0);
    this.writeFloat64(value);
  };

  // Adds on offset, relative to where it will be written
  FlatBuffers.Builder.prototype.addOffset = function(value) {
    // Ensure alignment is already done
    this.prep(FlatBuffers.SIZEOF_INT, 0);
    this.writeInt32((this.offset() - value | 0) + FlatBuffers.SIZEOF_INT | 0);
  };

  FlatBuffers.Builder.prototype.addFieldInt8 = function(voffset, value, defaultValue) {
    if (this._forceDefaults || value != defaultValue) {
      this.addInt8(value);
      this.slot(voffset);
    }
  };

  FlatBuffers.Builder.prototype.addFieldInt16 = function(voffset, value, defaultValue) {
    if (this._forceDefaults || value != defaultValue) {
      this.addInt16(value);
      this.slot(voffset);
    }
  };

  FlatBuffers.Builder.prototype.addFieldInt32 = function(voffset, value, defaultValue) {
    if (this._forceDefaults || value != defaultValue) {
      this.addInt32(value);
      this.slot(voffset);
    }
  };

  FlatBuffers.Builder.prototype.addFieldInt64 = function(voffset, value, defaultValue) {
    if (this._forceDefaults || !value.isEqualTo(defaultValue)) {
      this.addInt64(value);
      this.slot(voffset);
    }
  };

  FlatBuffers.Builder.prototype.addFieldFloat32 = function(voffset, value, defaultValue) {
    if (this._forceDefaults || value != defaultValue) {
      this.addFloat32(value);
      this.slot(voffset);
    }
  };

  FlatBuffers.Builder.prototype.addFieldFloat64 = function(voffset, value, defaultValue) {
    if (this._forceDefaults || value != defaultValue) {
      this.addFloat64(value);
      this.slot(voffset);
    }
  };

  FlatBuffers.Builder.prototype.addFieldOffset = function(voffset, value, defaultValue) {
    if (this._forceDefaults || value != defaultValue) {
      this.addOffset(value);
      this.slot(voffset);
    }
  };

  // Structs are stored inline, so nothing additional is being added. "d" is
  // always 0.
  FlatBuffers.Builder.prototype.addFieldStruct = function(voffset, value, defaultValue) {
    if (value != defaultValue) {
      // Structures are always stored inline, they need to be created right
      // where they're used. You'll get this assertion failure if you
      // created it elsewhere.
      assert(value == this.offset());
      this.slot(voffset);
    }
  };

  FlatBuffers.Builder.prototype.pad = function(byteCount) {
    for (var i = 0, count = byteCount; i < count; i = i + 1 | 0) {
      this._bb.writeInt8(this._space = this._space - 1 | 0, 0);
    }
  };

  // Prepare to write an element of "size" after "additionalBytes" have been
  // written, e.g. if you write a string, you need to align such the int
  // length field is aligned to 4 bytes, and the string data follows it
  // directly. If all you need to do is alignment, "additionalBytes" will be
  // 0.
  FlatBuffers.Builder.prototype.prep = function(size, additionalBytes) {
    // Track the biggest thing we've ever aligned to.
    if (size > this._minAlign) {
      this._minAlign = size;
    }

    // Find the amount of alignment needed such that "size" is properly
    // aligned after "additionalBytes"
    var alignSize = ~((this._bb.capacity() - this._space | 0) + additionalBytes) + 1 & size - 1;

    // Reallocate the buffer if needed.
    while (this._space < ((alignSize + size | 0) + additionalBytes | 0)) {
      var old = this._bb.capacity();
      this._bb.grow();
      this._space = this._space + (this._bb.capacity() - old | 0) | 0;
    }

    this.pad(alignSize);
  };

  // Start encoding a new object in the buffer. Users will not usually need to
  // call this directly. The FlatBuffers compiler will generate helper methods
  // that call this method internally.
  FlatBuffers.Builder.prototype.startObject = function(fieldCount) {
    assert(!this._isNested);
    this._vtableInUse = fieldCount;

    while (in_List.count(this._vtable) < fieldCount) {
      this._vtable.push(0);
    }

    this._isNested = true;
    this._objectStart = this.offset();
  };

  // Finish off writing the object that is under construction.
  FlatBuffers.Builder.prototype.endObject = function() {
    assert(this._isNested);
    this.addInt32(0);
    var vtableOffset = this.offset();

    // Write out the current vtable.
    for (var i = 0, count = this._vtableInUse; i < count; i = i + 1 | 0) {
      // Offset relative to the start of the table.
      var entry = in_List.get(this._vtable, (this._vtableInUse - i | 0) - 1 | 0);
      this.addInt16(entry != 0 ? vtableOffset - entry | 0 : 0);
    }

    // The fields below:
    var standardFields = 2;
    this.addInt16(vtableOffset - this._objectStart | 0);
    this.addInt16(__imul(this._vtableInUse + standardFields | 0, FlatBuffers.SIZEOF_SHORT));

    // Search for an existing vtable that matches the current one.
    var existingVtable = 0;

    for (var i1 = 0, list = this._vtables, count1 = in_List.count(list); i1 < count1; i1 = i1 + 1 | 0) {
      var vtable = in_List.get(list, i1);
      var vt1 = this._bb.capacity() - vtable | 0;
      var vt2 = this._space;
      var len = this._bb.readInt16(vt1);

      if (len == this._bb.readInt16(vt2)) {
        var found = false;

        for (var j = FlatBuffers.SIZEOF_SHORT; j < len; j = j + FlatBuffers.SIZEOF_SHORT | 0) {
          if (this._bb.readInt16(vt1 + j | 0) != this._bb.readInt16(vt2 + j | 0)) {
            found = true;
            break;
          }
        }

        if (!found) {
          existingVtable = vtable;
          break;
        }
      }
    }

    if (existingVtable != 0) {
      // Found a match:
      // Remove the current vtable.
      this._space = this._bb.capacity() - vtableOffset | 0;

      // Point table to existing vtable.
      this._bb.writeInt32(this._space, existingVtable - vtableOffset | 0);
    }

    else {
      // No match:
      // Add the location of the current vtable to the list of vtables.
      this._vtables.push(this.offset());

      // Point table to current vtable.
      this._bb.writeInt32(this._bb.capacity() - vtableOffset | 0, this.offset() - vtableOffset | 0);
    }

    this._isNested = false;
    return vtableOffset;
  };

  FlatBuffers.Builder.prototype.finish = function(root_table, file_identifier) {
    if (file_identifier != null) {
      assert(in_string.count(file_identifier) == FlatBuffers.FILE_IDENTIFIER_LENGTH);
      this.prep(this._minAlign, FlatBuffers.SIZEOF_INT + FlatBuffers.FILE_IDENTIFIER_LENGTH | 0);

      for (var i = 0; i < FlatBuffers.FILE_IDENTIFIER_LENGTH; i = i + 1 | 0) {
        this.writeInt8(in_string.get1(file_identifier, (FlatBuffers.FILE_IDENTIFIER_LENGTH - 1 | 0) - i | 0));
      }
    }

    this.prep(this._minAlign, FlatBuffers.SIZEOF_INT);
    this.addOffset(root_table);
    this._bb.setPosition(this._space);
  };

  // This checks a required field has been set in a given table that has
  // just been constructed.
  FlatBuffers.Builder.prototype.requiredField = function(table, field) {
    if (!RELEASE) {
      var tableStart = this._bb.capacity() - table | 0;
      var vtableStart = tableStart - this._bb.readInt32(tableStart) | 0;
      assert(this._bb.readInt16(vtableStart + field | 0) != 0);
    }
  };

  // Start a new array/vector of objects.  Users usually will not call
  // this directly. The FlatBuffers compiler will create a start/end
  // method for vector types in generated code.
  FlatBuffers.Builder.prototype.startVector = function(elementSize, elementCount, alignment) {
    assert(!this._isNested);
    this._vectorCount = elementCount;
    this.prep(FlatBuffers.SIZEOF_INT, __imul(elementSize, elementCount));

    // Just in case alignment > int
    this.prep(alignment, __imul(elementSize, elementCount));
  };

  // Finish off the creation of an array and all its elements. The array must
  // be created with "startVector".
  FlatBuffers.Builder.prototype.endVector = function() {
    this.writeInt32(this._vectorCount);
    return this.offset();
  };

  // Encode the string "s" in the buffer using UTF-8.
  FlatBuffers.Builder.prototype.createString = function(s) {
    var utf8 = [];

    // Encode UTF-8
    for (var i = 0, list = in_string.codePoints(s), count = in_List.count(list); i < count; i = i + 1 | 0) {
      var codePoint = in_List.get(list, i);

      if (codePoint < 128) {
        utf8.push(codePoint);
      }

      else {
        if (codePoint < 2048) {
          utf8.push(codePoint >> 6 & 31 | 192);
        }

        else {
          if (codePoint < 65536) {
            utf8.push(codePoint >> 12 & 15 | 224);
          }

          else {
            utf8.push(codePoint >> 18 & 7 | 240);
            utf8.push(codePoint >> 12 & 63 | 128);
          }

          utf8.push(codePoint >> 6 & 63 | 128);
        }

        utf8.push(codePoint & 63 | 128);
      }
    }

    this.addInt8(0);
    this.startVector(1, in_List.count(utf8), 1);
    this._space = this._space - in_List.count(utf8) | 0;
    this._bb.setPosition(this._space);
    var bytes = this._bb.bytes();
    var offset = this._space;

    for (var i1 = 0, list1 = utf8, count1 = in_List.count(list1); i1 < count1; i1 = i1 + 1 | 0) {
      var codeUnit = in_List.get(list1, i1);
      bytes[offset] = codeUnit;
      offset = offset + 1 | 0;
    }

    return this.endVector();
  };

  FlatBuffers.Builder.new1 = function() {
    return new FlatBuffers.Builder(FlatBuffers.DEFAULT_BUFFER_SIZE);
  };

  FlatBuffers.ByteBuffer = function(bytes) {
    this._bytes = null;
    this._view = null;
    this._position = 0;
    this._bytes = bytes;
    this._view = in_DataView.new1(bytes);
  };

  FlatBuffers.ByteBuffer.new2 = function(count) {
    this._bytes = null;
    this._view = null;
    this._position = 0;
    this._bytes = new Uint8Array(count);
    this._view = in_DataView.new1(this._bytes);
  };

  FlatBuffers.ByteBuffer.new2.prototype = FlatBuffers.ByteBuffer.prototype;

  FlatBuffers.ByteBuffer.prototype.bytes = function() {
    return this._bytes;
  };

  FlatBuffers.ByteBuffer.prototype.position = function() {
    return this._position;
  };

  FlatBuffers.ByteBuffer.prototype.setPosition = function(value) {
    this._position = value;
  };

  FlatBuffers.ByteBuffer.prototype.capacity = function() {
    return this._bytes.length;
  };

  FlatBuffers.ByteBuffer.prototype.readInt8 = function(offset) {
    return this._view.getInt8(offset);
  };

  FlatBuffers.ByteBuffer.prototype.readUint8 = function(offset) {
    return this._view.getUint8(offset);
  };

  FlatBuffers.ByteBuffer.prototype.readInt16 = function(offset) {
    return this._view.getInt16(offset, true);
  };

  FlatBuffers.ByteBuffer.prototype.readInt32 = function(offset) {
    return this._view.getInt32(offset, true);
  };

  FlatBuffers.ByteBuffer.prototype.readInt64 = function(offset) {
    return new FlatBuffers.Long(this.readInt32(offset), this.readInt32(offset + 4 | 0));
  };

  FlatBuffers.ByteBuffer.prototype.readFloat32 = function(offset) {
    return this._view.getFloat32(offset, true);
  };

  FlatBuffers.ByteBuffer.prototype.readFloat64 = function(offset) {
    return this._view.getFloat64(offset, true);
  };

  FlatBuffers.ByteBuffer.prototype.writeInt8 = function(offset, value) {
    this._view.setInt8(offset, value);
  };

  FlatBuffers.ByteBuffer.prototype.writeInt16 = function(offset, value) {
    this._view.setInt16(offset, value, true);
  };

  FlatBuffers.ByteBuffer.prototype.writeInt32 = function(offset, value) {
    this._view.setInt32(offset, value, true);
  };

  FlatBuffers.ByteBuffer.prototype.writeInt64 = function(offset, value) {
    this.writeInt32(offset, value.low);
    this.writeInt32(offset + 4 | 0, value.high);
  };

  FlatBuffers.ByteBuffer.prototype.writeFloat32 = function(offset, value) {
    this._view.setFloat32(offset, value, true);
  };

  FlatBuffers.ByteBuffer.prototype.writeFloat64 = function(offset, value) {
    this._view.setFloat64(offset, value, true);
  };

  FlatBuffers.ByteBuffer.prototype.hasIdentifier = function(identifier) {
    assert(in_string.count(identifier) == FlatBuffers.FILE_IDENTIFIER_LENGTH);

    for (var i = 0; i < FlatBuffers.FILE_IDENTIFIER_LENGTH; i = i + 1 | 0) {
      if (in_string.get1(identifier, i) != this.readInt8((this._position + FlatBuffers.SIZEOF_INT | 0) + i | 0)) {
        return false;
      }
    }

    return true;
  };

  // Retrieve the relative offset stored at "offset"
  FlatBuffers.ByteBuffer.prototype.readIndirect = function(offset) {
    return offset + this.readInt32(offset) | 0;
  };

  // Get the start of data of a vector whose offset is stored at "offset" in
  // this object.
  FlatBuffers.ByteBuffer.prototype.readVector = function(offset) {
    // data starts after the length
    return (offset + this.readInt32(offset) | 0) + 4 | 0;
  };

  // Get the length of a vector whose offset is stored at "offset" in this
  // object.
  FlatBuffers.ByteBuffer.prototype.readVectorLength = function(offset) {
    return this.readInt32(offset + this.readInt32(offset) | 0);
  };

  // Look up a field in the vtable, return an offset into the object, or 0 if
  // the field is not present.
  FlatBuffers.ByteBuffer.prototype.readOffset = function(bb_pos, vtable_offset) {
    var vtable = bb_pos - this.readInt32(bb_pos) | 0;
    return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset | 0) : 0;
  };

  // Initialize any Table-derived type to point to the union at the given offset.
  FlatBuffers.ByteBuffer.prototype.readUnion = function(offset) {
    return offset + this.readInt32(offset) | 0;
  };

  // Create a JavaScript string from UTF-8 data stored inside the flatbuffer.
  // This allocates a new string and converts to wide chars upon each access.
  FlatBuffers.ByteBuffer.prototype.readString = function(offset) {
    offset = offset + this.readInt32(offset) | 0;
    var length = this.readInt32(offset);
    var builder = new StringBuilder();
    var i = 0;
    offset = offset + 4 | 0;

    while (i < length) {
      var codePoint = 0;

      // Decode UTF-8
      var a = this.readUint8(offset + i | 0);
      i = i + 1 | 0;

      if (a < 192) {
        codePoint = a;
      }

      else {
        var b = this.readUint8(offset + i | 0);
        i = i + 1 | 0;

        if (a < 224) {
          codePoint = (a & 31) << 6 | b & 63;
        }

        else {
          var c = this.readUint8(offset + i | 0);
          i = i + 1 | 0;

          if (a < 240) {
            codePoint = (a & 15) << 12 | (b & 63) << 6 | c & 63;
          }

          else {
            var d = this.readUint8(offset + i | 0);
            i = i + 1 | 0;
            codePoint = (a & 7) << 18 | (b & 63) << 12 | (c & 63) << 6 | d & 63;
          }
        }
      }

      // Encode UTF-16
      builder.append(in_string.fromCodePoint(codePoint));
    }

    return builder.toString();
  };

  // Doubles the size of this ByteBuffer and copies the old data towards
  // the end of the new buffer (since we build the buffer backwards)
  FlatBuffers.ByteBuffer.prototype.grow = function() {
    var oldSize = this.capacity();

    // Ensure we don't grow beyond what fits in an int.
    assert((oldSize & -1073741824) == 0);
    var newSize = __imul(oldSize, 2);
    var bytes = new Uint8Array(newSize);
    var position = newSize - oldSize | 0;
    bytes.set(this._bytes, position);
    this._bytes = bytes;
    this._view = in_DataView.new1(bytes);
    this._position = position;
  };

  var MyGame = {};
  MyGame.Example = {};
  MyGame.Example.Color = {};
  MyGame.Example.Any = {};
  MyGame.Example.Test = {};

  MyGame.Example.Test.a = function(self, bb) {
    return bb.readInt16(self + 0 | 0);
  };

  MyGame.Example.Test.b = function(self, bb) {
    return bb.readInt8(self + 2 | 0);
  };

  MyGame.Example.Test.createTest = function(builder, a, b) {
    builder.prep(2, 4);
    builder.pad(1);
    builder.writeInt8(b);
    builder.writeInt16(a);
    return builder.offset();
  };

  MyGame.Example.Vec3 = {};

  MyGame.Example.Vec3.x = function(self, bb) {
    return bb.readFloat32(self + 0 | 0);
  };

  MyGame.Example.Vec3.y = function(self, bb) {
    return bb.readFloat32(self + 4 | 0);
  };

  MyGame.Example.Vec3.z = function(self, bb) {
    return bb.readFloat32(self + 8 | 0);
  };

  MyGame.Example.Vec3.test1 = function(self, bb) {
    return bb.readFloat64(self + 16 | 0);
  };

  MyGame.Example.Vec3.test2 = function(self, bb) {
    return bb.readInt8(self + 24 | 0);
  };

  MyGame.Example.Vec3.test3 = function(self, bb) {
    return self + 26 | 0;
  };

  MyGame.Example.Vec3.createVec3 = function(builder, x, y, z, test1, test2, test3_a, test3_b) {
    builder.prep(16, 32);
    builder.pad(2);
    builder.prep(2, 4);
    builder.pad(1);
    builder.writeInt8(test3_b);
    builder.writeInt16(test3_a);
    builder.pad(1);
    builder.writeInt8(test2);
    builder.writeFloat64(test1);
    builder.pad(4);
    builder.writeFloat32(z);
    builder.writeFloat32(y);
    builder.writeFloat32(x);
    return builder.offset();
  };

  MyGame.Example.Stat = {};

  MyGame.Example.Stat.val = function(self, bb) {
    var offset = bb.readOffset(self, 6);
    return offset != 0 ? bb.readInt64(self + offset | 0) : FlatBuffers.Long.ZERO;
  };

  MyGame.Example.Stat.startStat = function(builder) {
    builder.startObject(3);
  };

  MyGame.Example.Stat.addVal = function(builder, val) {
    builder.addFieldInt64(1, val, FlatBuffers.Long.ZERO);
  };

  MyGame.Example.Stat.endStat = function(builder) {
    var offset = builder.endObject();
    return offset;
  };

  // an example documentation comment: monster object
  MyGame.Example.Monster = {};

  MyGame.Example.Monster.pos = function(self, bb) {
    var offset = bb.readOffset(self, 4);
    return offset != 0 ? self + offset | 0 : MyGame.Example.Vec3.NULL;
  };

  MyGame.Example.Monster.mana = function(self, bb) {
    var offset = bb.readOffset(self, 6);
    return offset != 0 ? bb.readInt16(self + offset | 0) : 150;
  };

  MyGame.Example.Monster.hp = function(self, bb) {
    var offset = bb.readOffset(self, 8);
    return offset != 0 ? bb.readInt16(self + offset | 0) : 100;
  };

  MyGame.Example.Monster.name = function(self, bb) {
    var offset = bb.readOffset(self, 10);
    return offset != 0 ? bb.readString(self + offset | 0) : null;
  };

  MyGame.Example.Monster.inventory = function(self, bb, index) {
    var offset = bb.readOffset(self, 14);
    return offset != 0 ? bb.readUint8(bb.readVector(self + offset | 0) + __imul(index, 1) | 0) : 0;
  };

  MyGame.Example.Monster.inventoryLength = function(self, bb) {
    var offset = bb.readOffset(self, 14);
    return offset != 0 ? bb.readVectorLength(self + offset | 0) : 0;
  };

  MyGame.Example.Monster.testType = function(self, bb) {
    var offset = bb.readOffset(self, 18);
    return offset != 0 ? bb.readUint8(self + offset | 0) : MyGame.Example.Any.NONE;
  };

  MyGame.Example.Monster.test = function(self, bb) {
    var offset = bb.readOffset(self, 20);
    return offset != 0 ? bb.readUnion(self + offset | 0) : 0;
  };

  MyGame.Example.Monster.test4 = function(self, bb, index) {
    var offset = bb.readOffset(self, 22);
    return offset != 0 ? bb.readVector(self + offset | 0) + __imul(index, 4) | 0 : MyGame.Example.Test.NULL;
  };

  MyGame.Example.Monster.test4Length = function(self, bb) {
    var offset = bb.readOffset(self, 22);
    return offset != 0 ? bb.readVectorLength(self + offset | 0) : 0;
  };

  MyGame.Example.Monster.testarrayofstring = function(self, bb, index) {
    var offset = bb.readOffset(self, 24);
    return offset != 0 ? bb.readString(bb.readVector(self + offset | 0) + __imul(index, 4) | 0) : null;
  };

  MyGame.Example.Monster.testarrayofstringLength = function(self, bb) {
    var offset = bb.readOffset(self, 24);
    return offset != 0 ? bb.readVectorLength(self + offset | 0) : 0;
  };

  // an example documentation comment: this will end up in the generated code
  // multiline too
  MyGame.Example.Monster.testarrayoftables = function(self, bb, index) {
    var offset = bb.readOffset(self, 26);
    return offset != 0 ? bb.readIndirect(bb.readVector(self + offset | 0) + __imul(index, 4) | 0) : MyGame.Example.Monster.NULL;
  };

  MyGame.Example.Monster.testarrayoftablesLength = function(self, bb) {
    var offset = bb.readOffset(self, 26);
    return offset != 0 ? bb.readVectorLength(self + offset | 0) : 0;
  };

  MyGame.Example.Monster.enemy = function(self, bb) {
    var offset = bb.readOffset(self, 28);
    return offset != 0 ? bb.readIndirect(self + offset | 0) : MyGame.Example.Monster.NULL;
  };

  MyGame.Example.Monster.testempty = function(self, bb) {
    var offset = bb.readOffset(self, 32);
    return offset != 0 ? bb.readIndirect(self + offset | 0) : MyGame.Example.Stat.NULL;
  };

  MyGame.Example.Monster.testbool = function(self, bb) {
    var offset = bb.readOffset(self, 34);
    return offset != 0 ? !!bb.readInt8(self + offset | 0) : false;
  };

  MyGame.Example.Monster.getRootAsMonster = function(bb) {
    return bb.readInt32(bb.position()) + bb.position() | 0;
  };

  MyGame.Example.Monster.bufferHasIdentifier = function(bb) {
    return bb.hasIdentifier('MONS');
  };

  MyGame.Example.Monster.startMonster = function(builder) {
    builder.startObject(25);
  };

  MyGame.Example.Monster.addPos = function(builder, posOffset) {
    builder.addFieldStruct(0, posOffset, 0);
  };

  MyGame.Example.Monster.addHp = function(builder, hp) {
    builder.addFieldInt16(2, hp, 100);
  };

  MyGame.Example.Monster.addName = function(builder, nameOffset) {
    builder.addFieldOffset(3, nameOffset, 0);
  };

  MyGame.Example.Monster.addInventory = function(builder, inventoryOffset) {
    builder.addFieldOffset(5, inventoryOffset, 0);
  };

  MyGame.Example.Monster.createInventoryVector = function(builder, data) {
    builder.startVector(1, in_List.count(data), 1);

    for (var i = in_List.count(data) - 1 | 0; i >= 0; i = i - 1 | 0) {
      builder.addInt8(in_List.get(data, i));
    }

    return builder.endVector();
  };

  MyGame.Example.Monster.addTestType = function(builder, testType) {
    builder.addFieldInt8(7, testType, MyGame.Example.Any.NONE);
  };

  MyGame.Example.Monster.addTest = function(builder, testOffset) {
    builder.addFieldOffset(8, testOffset, 0);
  };

  MyGame.Example.Monster.addTest4 = function(builder, test4Offset) {
    builder.addFieldOffset(9, test4Offset, 0);
  };

  MyGame.Example.Monster.startTest4Vector = function(builder, numElems) {
    builder.startVector(4, numElems, 2);
  };

  MyGame.Example.Monster.endTest4Vector = function(builder) {
    return builder.endVector();
  };

  MyGame.Example.Monster.addTestarrayofstring = function(builder, testarrayofstringOffset) {
    builder.addFieldOffset(10, testarrayofstringOffset, 0);
  };

  MyGame.Example.Monster.createTestarrayofstringVector = function(builder, data) {
    builder.startVector(4, in_List.count(data), 4);

    for (var i = in_List.count(data) - 1 | 0; i >= 0; i = i - 1 | 0) {
      builder.addOffset(in_List.get(data, i));
    }

    return builder.endVector();
  };

  MyGame.Example.Monster.addTestarrayoftables = function(builder, testarrayoftablesOffset) {
    builder.addFieldOffset(11, testarrayoftablesOffset, 0);
  };

  MyGame.Example.Monster.createTestarrayoftablesVector = function(builder, data) {
    builder.startVector(4, in_List.count(data), 4);

    for (var i = in_List.count(data) - 1 | 0; i >= 0; i = i - 1 | 0) {
      builder.addOffset(in_List.get(data, i));
    }

    return builder.endVector();
  };

  MyGame.Example.Monster.addEnemy = function(builder, enemyOffset) {
    builder.addFieldOffset(12, enemyOffset, 0);
  };

  MyGame.Example.Monster.addTestempty = function(builder, testemptyOffset) {
    builder.addFieldOffset(14, testemptyOffset, 0);
  };

  MyGame.Example.Monster.addTestbool = function(builder, testbool) {
    builder.addFieldInt8(15, testbool | 0, 0);
  };

  MyGame.Example.Monster.endMonster = function(builder) {
    var offset = builder.endObject();

    // name
    builder.requiredField(offset, 10);
    return offset;
  };

  MyGame.Example.Monster.finishMonsterBuffer = function(builder, offset) {
    builder.finish(offset, 'MONS');
  };

  var in_string = {};

  in_string.count = function(self) {
    return self.length;
  };

  in_string.get1 = function(self, index) {
    assert(0 <= index && index < in_string.count(self));
    return self.charCodeAt(index);
  };

  in_string.fromCodeUnit = function(codeUnit) {
    return String.fromCharCode(codeUnit);
  };

  in_string.codePoints = function(self) {
    var codePoints = [];
    var instance = Unicode.StringIterator.INSTANCE;
    instance.reset(self, 0);

    while (true) {
      var codePoint = instance.nextCodePoint();

      if (codePoint < 0) {
        return codePoints;
      }

      codePoints.push(codePoint);
    }
  };

  in_string.fromCodePoint = function(codePoint) {
    return codePoint < 65536 ? in_string.fromCodeUnit(codePoint) : in_string.fromCodeUnit((codePoint - 65536 >> 10) + 55296 | 0) + in_string.fromCodeUnit((codePoint - 65536 & (1 << 10) - 1) + 56320 | 0);
  };

  var in_List = {};

  in_List.get = function(self, index) {
    assert(0 <= index && index < in_List.count(self));
    return self[index];
  };

  in_List.set = function(self, index, value) {
    assert(0 <= index && index < in_List.count(self));
    return self[index] = value;
  };

  in_List.count = function(self) {
    return self.length;
  };

  var in_DataView = {};

  in_DataView.new1 = function(array) {
    return new DataView(array.buffer, array.byteOffset, array.byteLength);
  };

  var RELEASE = false;
  var fs = require('fs');

  // Include simple random number generator to ensure results will be the
  // same cross platform.
  // http://en.wikipedia.org/wiki/Park%E2%80%93Miller_random_number_generator
  var rand_seed = 1;
  Unicode.StringIterator.INSTANCE = new Unicode.StringIterator();
  FlatBuffers.FILE_IDENTIFIER_LENGTH = 4;
  FlatBuffers.DEFAULT_BUFFER_SIZE = 1024;
  FlatBuffers.SIZEOF_SHORT = 2;
  FlatBuffers.SIZEOF_INT = 4;
  FlatBuffers.Long.ZERO = new FlatBuffers.Long(0, 0);
  MyGame.Example.Color.Green = 2;
  MyGame.Example.Any.NONE = 0;
  MyGame.Example.Any.Monster = 1;
  MyGame.Example.Test.NULL = 0;
  MyGame.Example.Vec3.NULL = 0;
  MyGame.Example.Stat.NULL = 0;
  MyGame.Example.Monster.NULL = 0;

  main();
})();
