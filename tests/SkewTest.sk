var fs = dynamic.require("fs")

@entry
def main {
  # First, let's test reading a FlatBuffer generated by C++ code:
  # This file was generated from monsterdata_test.json
  var data = Uint8Array.new(fs.readFileSync("monsterdata_test.mon"))

  # Now test it:

  var bb = FlatBuffers.ByteBuffer.new(data)
  testBuffer(bb)

  # Second, let's create a FlatBuffer from scratch in JavaScript, and test it also.
  # We use an initial size of 1 to exercise the reallocation algorithm,
  # normally a size larger than the typical FlatBuffer you generate would be
  # better for performance.
  var fbb = FlatBuffers.Builder.new(1)

  # We set up the same values as monsterdata.json:

  var str = fbb.createString("MyMonster")

  var inv = MyGame.Example.Monster.createInventoryVector(fbb, [0, 1, 2, 3, 4])

  var fred = fbb.createString("Fred")
  MyGame.Example.Monster.startMonster(fbb)
  MyGame.Example.Monster.addName(fbb, fred)
  var mon2 = MyGame.Example.Monster.endMonster(fbb)

  MyGame.Example.Monster.startTest4Vector(fbb, 2)
  MyGame.Example.Test.createTest(fbb, 10, 20)
  MyGame.Example.Test.createTest(fbb, 30, 40)
  var test4 = MyGame.Example.Monster.endTest4Vector(fbb)

  var testArrayOfString = MyGame.Example.Monster.createTestarrayofstringVector(fbb, [
    fbb.createString("test1"),
    fbb.createString("test2")
  ])

  MyGame.Example.Monster.startMonster(fbb)
  MyGame.Example.Monster.addPos(fbb, MyGame.Example.Vec3.createVec3(fbb, 1, 2, 3, 3, .Green, 5, 6))
  MyGame.Example.Monster.addHp(fbb, 80)
  MyGame.Example.Monster.addName(fbb, str)
  MyGame.Example.Monster.addInventory(fbb, inv)
  MyGame.Example.Monster.addTestType(fbb, .Monster)
  MyGame.Example.Monster.addTest(fbb, mon2 as MyGame.Example.Any)
  MyGame.Example.Monster.addTest4(fbb, test4)
  MyGame.Example.Monster.addTestarrayofstring(fbb, testArrayOfString)
  MyGame.Example.Monster.addTestbool(fbb, false)
  var mon = MyGame.Example.Monster.endMonster(fbb)

  MyGame.Example.Monster.finishMonsterBuffer(fbb, mon)

  # Write the result to a file for debugging purposes:
  # Note that the binaries are not necessarily identical, since the JSON
  # parser may serialize in a slightly different order than the above
  # JavaScript code. They are functionally equivalent though.

  fs.writeFileSync("monsterdata_skew_wire.mon", dynamic.Buffer.new(fbb.asUint8Array))

  # Test it:
  testBuffer(fbb.dataBuffer)

  test64bit
  testUnicode
  fuzzTest1

  dynamic.console.log("FlatBuffers test: completed successfully")
}

def testBuffer(bb FlatBuffers.ByteBuffer) {
  assert(MyGame.Example.Monster.bufferHasIdentifier(bb))

  var monster = MyGame.Example.Monster.getRootAsMonster(bb)

  assert(monster.hp(bb) == 80)
  assert(monster.mana(bb) == 150) # default

  assert(monster.name(bb) == "MyMonster")

  var pos = monster.pos(bb)
  assert(pos.x(bb) == 1)
  assert(pos.y(bb) == 2)
  assert(pos.z(bb) == 3)
  assert(pos.test1(bb) == 3)
  assert(pos.test2(bb) == .Green)
  var t = pos.test3(bb)
  assert(t.a(bb) == 5)
  assert(t.b(bb) == 6)

  assert(monster.testType(bb) == .Monster)
  var monster2 = monster.test(bb) as MyGame.Example.Monster
  assert(monster2 != .NULL)
  assert(monster2.name(bb) == "Fred")

  assert(monster.inventoryLength(bb) == 5)
  var invsum = 0
  for i in 0..monster.inventoryLength(bb) {
    invsum += monster.inventory(bb, i)
  }
  assert(invsum == 10)

  assert(monster.test4Length(bb) == 2)
  var test_0 = monster.test4(bb, 0)
  var test_1 = monster.test4(bb, 1)
  assert(test_0.a(bb) + test_0.b(bb) + test_1.a(bb) + test_1.b(bb) == 100)

  assert(monster.testarrayofstringLength(bb) == 2)
  assert(monster.testarrayofstring(bb, 0) == "test1")
  assert(monster.testarrayofstring(bb, 1) == "test2")

  assert(monster.testbool(bb) == false)
}

def test64bit {
  var fbb = FlatBuffers.Builder.new
  var required = fbb.createString("required")

  MyGame.Example.Stat.startStat(fbb)
  var stat2 = MyGame.Example.Stat.endStat(fbb)

  MyGame.Example.Monster.startMonster(fbb)
  MyGame.Example.Monster.addName(fbb, required)
  MyGame.Example.Monster.addTestempty(fbb, stat2)
  var mon2 = MyGame.Example.Monster.endMonster(fbb)

  MyGame.Example.Stat.startStat(fbb)
  MyGame.Example.Stat.addVal(fbb, FlatBuffers.Long.new(0x12345678, 0x23456789))
  var stat = MyGame.Example.Stat.endStat(fbb)

  MyGame.Example.Monster.startMonster(fbb)
  MyGame.Example.Monster.addName(fbb, required)
  MyGame.Example.Monster.addEnemy(fbb, mon2)
  MyGame.Example.Monster.addTestempty(fbb, stat)
  var mon3 = MyGame.Example.Monster.endMonster(fbb)

  MyGame.Example.Monster.finishMonsterBuffer(fbb, mon3)
  var bytes = fbb.asUint8Array

  ###############################################################

  var bb = FlatBuffers.ByteBuffer.new(bytes)
  assert(MyGame.Example.Monster.bufferHasIdentifier(bb))
  var mon4 = MyGame.Example.Monster.getRootAsMonster(bb)

  var stat3 = mon4.testempty(bb)
  assert(stat3 != .NULL)
  assert(stat3.val(bb) != null)
  assert(stat3.val(bb).low == 0x12345678)
  assert(stat3.val(bb).high == 0x23456789)

  var mon5 = mon4.enemy(bb)
  assert(mon5 != .NULL)
  stat3 = mon5.testempty(bb)
  assert(stat3 != .NULL)
  assert(stat3.val(bb) != null)
  assert(stat3.val(bb).low == 0) # default value
  assert(stat3.val(bb).high == 0)
}

def testUnicode {
  var correct = fs.readFileSync("unicode_test.mon")
  var json = dynamic.JSON.parse(fs.readFileSync("unicode_test.json", "utf8"))

  # Test reading
  var testReadingUnicode = (bb FlatBuffers.ByteBuffer) => {
    var monster = MyGame.Example.Monster.getRootAsMonster(bb)
    assert(monster.name(bb) == json.name)
    assert(monster.testarrayoftablesLength(bb) == json.testarrayoftables.length)
    json.testarrayoftables.forEach((table dynamic, i int) => {
      var value = monster.testarrayoftables(bb, i)
      assert(value.name(bb) == table.name)
    })
    assert(monster.testarrayofstringLength(bb) == json.testarrayofstring.length)
    json.testarrayofstring.forEach((value string, i int) => {
      assert(monster.testarrayofstring(bb, i) == value)
    })
  }
  testReadingUnicode(FlatBuffers.ByteBuffer.new(Uint8Array.new(correct)))

  # Test writing
  var fbb = FlatBuffers.Builder.new
  var name = fbb.createString(json.name)
  var testarrayoftablesOffsets = json.testarrayoftables.map(table => {
    var name = fbb.createString(table.name)
    MyGame.Example.Monster.startMonster(fbb)
    MyGame.Example.Monster.addName(fbb, name)
    return MyGame.Example.Monster.endMonster(fbb)
  })
  var testarrayoftablesOffset = MyGame.Example.Monster.createTestarrayoftablesVector(fbb, testarrayoftablesOffsets)
  var testarrayofstringOffset = MyGame.Example.Monster.createTestarrayofstringVector(fbb, json.testarrayofstring.map(s => fbb.createString(s)))
  MyGame.Example.Monster.startMonster(fbb)
  MyGame.Example.Monster.addTestarrayofstring(fbb, testarrayofstringOffset)
  MyGame.Example.Monster.addTestarrayoftables(fbb, testarrayoftablesOffset)
  MyGame.Example.Monster.addName(fbb, name)
  MyGame.Example.Monster.finishMonsterBuffer(fbb, MyGame.Example.Monster.endMonster(fbb))
  testReadingUnicode(FlatBuffers.ByteBuffer.new(fbb.asUint8Array))
}

# Include simple random number generator to ensure results will be the
# same cross platform.
# http://en.wikipedia.org/wiki/Park%E2%80%93Miller_random_number_generator
var rand_seed = 1

def rand int {
  return rand_seed = (rand_seed * 1103515245 + 12345) & 0x7FFFFFFF
}

def rand_reset {
  rand_seed = 1
}

# Converts a Field ID to a virtual table offset.
def fieldIndexToOffset(field_id int) int {
  # Should correspond to what EndTable() below builds up.
  var fixed_fields = 2  # Vtable size and Object Size.
  return (field_id + fixed_fields) * 2
}

# Low level stress/fuzz test: serialize/deserialize a variety of
# different kinds of data in different combinations
def fuzzTest1 {

  # Values we're testing against: chosen to ensure no bits get chopped
  # off anywhere, and also be different from eachother.
  var bool_val   = true
  var char_val   = -127  # 0x81
  var uchar_val  = 0xFF
  var short_val  = -32222 # 0x8222;
  var ushort_val = 0xFEEE
  var int_val    = 0x83333333 | 0
  var uint_val   = 0xFDDDDDDD
  var long_val   = FlatBuffers.Long.new(0x44444444, 0x84444444)
  var ulong_val  = FlatBuffers.Long.new(0xCCCCCCCC, 0xFCCCCCCC)
  var float_val  = Float32Array.new([3.14159])[0]
  var double_val = 3.14159265359

  var test_values_max = 11
  var fields_per_object = 4
  var num_fuzz_objects = 10000  # The higher, the more thorough :)

  var builder = FlatBuffers.Builder.new

  rand_reset  # Keep it deterministic.

  var objects List<int> = []

  # Generate num_fuzz_objects random objects each consisting of
  # fields_per_object fields, each of a random type.
  for i in 0..num_fuzz_objects {
    builder.startObject(fields_per_object)
    for f in 0..fields_per_object {
      var choice = rand % test_values_max
      switch choice {
        case 0 {  builder.addFieldInt8(f, bool_val as int, 0) }
        case 1 {  builder.addFieldInt8(f, char_val,        0) }
        case 2 {  builder.addFieldInt8(f, uchar_val,       0) }
        case 3 {  builder.addFieldInt16(f, short_val,      0) }
        case 4 {  builder.addFieldInt16(f, ushort_val,     0) }
        case 5 {  builder.addFieldInt32(f, int_val,        0) }
        case 6 {  builder.addFieldInt32(f, uint_val,       0) }
        case 7 {  builder.addFieldInt64(f, long_val,       .ZERO) }
        case 8 {  builder.addFieldInt64(f, ulong_val,      .ZERO) }
        case 9 {  builder.addFieldFloat32(f, float_val,    0) }
        case 10 { builder.addFieldFloat64(f, double_val,   0) }
      }
    }
    objects.append(builder.endObject)
  }
  builder.prep(8, 0)  # Align whole buffer.

  rand_reset  # Reset.

  builder.finish(objects[objects.count - 1], null)
  var bytes = Uint8Array.new(builder.asUint8Array)
  var view = DataView.new(bytes.buffer)

  # Test that all objects we generated are readable and return the
  # expected values. We generate random objects in the same order
  # so this is deterministic.
  for i in 0..num_fuzz_objects {
    var offset = bytes.length - objects[i]
    for f in 0..fields_per_object {
      var choice = rand % test_values_max
      var vtable_offset = fieldIndexToOffset(f)
      var vtable = offset - view.getInt32(offset, true)
      assert(vtable_offset < view.getInt16(vtable, true))
      var field_offset = offset + view.getInt16(vtable + vtable_offset, true)
      switch choice {
        case 0 {  assert(view.getInt8(field_offset) as bool == bool_val) }
        case 1 {  assert(view.getInt8(field_offset) == char_val) }
        case 2 {  assert(view.getUint8(field_offset) == uchar_val) }
        case 3 {  assert(view.getInt16(field_offset, true) == short_val) }
        case 4 {  assert(view.getUint16(field_offset, true) == ushort_val) }
        case 5 {  assert(view.getInt32(field_offset, true) == int_val) }
        case 6 {  assert(view.getUint32(field_offset, true) as dynamic as int == uint_val) }
        case 7 {  assert(view.getInt32(field_offset, true) == long_val.low)
                  assert(view.getInt32(field_offset + 4, true) == long_val.high) }
        case 8 {  assert(view.getInt32(field_offset, true) == ulong_val.low)
                  assert(view.getInt32(field_offset + 4, true) == ulong_val.high) }
        case 9 {  assert(view.getFloat32(field_offset, true) == float_val) }
        case 10 { assert(view.getFloat64(field_offset, true) == double_val) }
      }
    }
  }
}
